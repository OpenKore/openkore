"""
Spirit Sphere Manager - Monk/Champion/Shura spirit sphere mechanics.

Manages the spirit sphere system used by Acolyte branch melee classes.
Tracks sphere count, consumption, and generation.
"""

import json
from pathlib import Path
from typing import Any

import structlog
from pydantic import BaseModel, ConfigDict, Field

logger = structlog.get_logger(__name__)


class SphereSkillRequirement(BaseModel):
    """Spirit sphere requirement for a skill."""

    model_config = ConfigDict(frozen=True)

    skill_name: str = Field(description="Skill name")
    spheres_required: int = Field(ge=0, le=15, description="Spheres needed")
    spheres_consumed: int = Field(ge=0, le=15, description="Spheres used up")


class SpiritSphereManager:
    """
    Manage Monk/Champion/Shura spirit spheres.

    Mechanics:
    - Max 5 spheres (15 with Rising Dragon)
    - Required for certain skills
    - Consumed by combo finishers
    - Generated by specific skills
    """

    def __init__(self, data_dir: Path | None = None) -> None:
        """
        Initialize spirit sphere manager.

        Args:
            data_dir: Optional data directory for skill requirements
        """
        self.log = structlog.get_logger()

        # State
        self.current_spheres: int = 0
        self.max_spheres: int = 5
        self.rising_dragon_active: bool = False

        # Skill requirements
        self.sphere_skills: dict[str, SphereSkillRequirement] = {}
        self.generation_skills: set[str] = set()

        if data_dir:
            self._load_sphere_skills(Path(data_dir))

    def _load_sphere_skills(self, data_dir: Path) -> None:
        """Load spirit sphere skill requirements from JSON."""
        skill_file = data_dir / "spirit_sphere_skills.json"

        if not skill_file.exists():
            self.log.warning(
                "spirit_sphere_skills.json not found",
                path=str(skill_file),
            )
            return

        try:
            with open(skill_file, encoding="utf-8") as f:
                data = json.load(f)

            # Load skills that use spheres
            skills_data = data.get("skills", {})
            for skill_name, skill_info in skills_data.items():
                req = SphereSkillRequirement(
                    skill_name=skill_name,
                    spheres_required=skill_info.get("spheres_required", 0),
                    spheres_consumed=skill_info.get("spheres_consumed", 0),
                )
                self.sphere_skills[skill_name] = req

            # Load generation skills
            self.generation_skills = set(data.get("generation_skills", []))

            self.log.info(
                "Spirit sphere skills loaded",
                skill_count=len(self.sphere_skills),
                generation_count=len(self.generation_skills),
            )

        except Exception as e:
            self.log.error(
                "Failed to load spirit_sphere_skills.json",
                error=str(e),
                path=str(skill_file),
            )

    def get_sphere_count(self) -> int:
        """Get current spirit sphere count."""
        return self.current_spheres

    def get_max_spheres(self) -> int:
        """Get maximum spirit spheres."""
        return self.max_spheres

    def set_sphere_count(self, count: int) -> None:
        """
        Set current sphere count.

        Args:
            count: New sphere count (clamped to 0-max)
        """
        self.current_spheres = max(0, min(count, self.max_spheres))
        self.log.debug("Spirit spheres updated", count=self.current_spheres)

    def can_use_skill(self, skill_name: str) -> tuple[bool, int]:
        """
        Check if we have enough spheres for skill.

        Args:
            skill_name: Skill to check

        Returns:
            Tuple of (can_use, spheres_required)
        """
        requirement = self.sphere_skills.get(skill_name)
        if not requirement:
            # Skill doesn't use spheres
            return True, 0

        can_use = self.current_spheres >= requirement.spheres_required
        return can_use, requirement.spheres_required

    def consume_spheres(self, skill_name: str) -> int:
        """
        Consume spheres when using skill.

        Args:
            skill_name: Skill being used

        Returns:
            Number of spheres consumed
        """
        requirement = self.sphere_skills.get(skill_name)
        if not requirement or requirement.spheres_consumed == 0:
            return 0

        consumed = min(requirement.spheres_consumed, self.current_spheres)
        self.current_spheres -= consumed

        self.log.debug(
            "Spirit spheres consumed",
            skill=skill_name,
            consumed=consumed,
            remaining=self.current_spheres,
        )

        return consumed

    def generate_sphere(self) -> bool:
        """
        Generate a spirit sphere.

        Returns:
            True if sphere was generated, False if at max
        """
        if self.current_spheres >= self.max_spheres:
            return False

        self.current_spheres += 1
        self.log.debug("Spirit sphere generated", count=self.current_spheres)
        return True

    def generate_multiple_spheres(self, count: int) -> int:
        """
        Generate multiple spirit spheres.

        Args:
            count: Number of spheres to generate

        Returns:
            Number of spheres actually generated
        """
        initial = self.current_spheres
        target = min(initial + count, self.max_spheres)
        generated = target - initial
        self.current_spheres = target

        if generated > 0:
            self.log.debug(
                "Multiple spheres generated",
                generated=generated,
                total=self.current_spheres,
            )

        return generated

    def should_generate_spheres(self, min_threshold: int = 3) -> bool:
        """
        Determine if we need to generate more spheres.

        Args:
            min_threshold: Minimum sphere count before generating

        Returns:
            True if we should generate spheres
        """
        return self.current_spheres < min_threshold

    def is_generation_skill(self, skill_name: str) -> bool:
        """
        Check if skill generates spirit spheres.

        Args:
            skill_name: Skill name

        Returns:
            True if skill generates spheres
        """
        return skill_name in self.generation_skills

    def activate_rising_dragon(self) -> None:
        """Activate Rising Dragon buff (increases max spheres to 15)."""
        if not self.rising_dragon_active:
            self.rising_dragon_active = True
            self.max_spheres = 15
            self.log.info("Rising Dragon activated", max_spheres=15)

    def deactivate_rising_dragon(self) -> None:
        """Deactivate Rising Dragon buff (returns max to 5)."""
        if self.rising_dragon_active:
            self.rising_dragon_active = False
            self.max_spheres = 5
            # Cap current spheres if over new max
            if self.current_spheres > self.max_spheres:
                self.current_spheres = self.max_spheres
            self.log.info("Rising Dragon deactivated", max_spheres=5)

    def get_sphere_skills(self) -> dict[str, dict[str, int]]:
        """
        Get skills and their sphere requirements.

        Returns:
            Dict of skill_name -> {required, consumed}
        """
        return {
            name: {
                "spheres_required": req.spheres_required,
                "spheres_consumed": req.spheres_consumed,
            }
            for name, req in self.sphere_skills.items()
        }

    def get_status(self) -> dict[str, Any]:
        """
        Get current spirit sphere status.

        Returns:
            Status dictionary
        """
        return {
            "current_spheres": self.current_spheres,
            "max_spheres": self.max_spheres,
            "rising_dragon_active": self.rising_dragon_active,
            "at_max": self.current_spheres >= self.max_spheres,
            "percentage": (
                (self.current_spheres / self.max_spheres * 100)
                if self.max_spheres > 0
                else 0
            ),
        }

    def reset(self) -> None:
        """Reset spirit sphere state (e.g., after death)."""
        self.current_spheres = 0
        self.rising_dragon_active = False
        self.max_spheres = 5
        self.log.debug("Spirit sphere state reset")